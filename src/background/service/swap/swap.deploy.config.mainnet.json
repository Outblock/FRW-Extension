{
  "Codes": {
    "Transactions": {
      "DeployPairTemplate": "import FlowToken from 0x1654653399040a61\ntransaction(pairTemplateCode: String) {\n    prepare(deployAccount: AuthAccount) {\n        let token0Vault <- FlowToken.createEmptyVault()\n        let token1Vault <- FlowToken.createEmptyVault()\n        deployAccount.contracts.add(name: \"SwapPair\", code: pairTemplateCode.utf8, token0Vault: <-token0Vault, token1Vault: <-token1Vault)\n    }\n}",
      "CreatePairTemplate": "import Token0Name from Token0Addr\nimport Token1Name from Token1Addr\nimport FlowToken from 0x1654653399040a61\nimport SwapFactory from 0xb063c16cac85dbd1\ntransaction() {\n    prepare(userAccount: AuthAccount) {\n        let flowVaultRef = userAccount.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)!\n        assert(flowVaultRef.balance >= 0.002, message: \"Insufficient balance to create pair, minimum balance requirement: 0.002 flow\")\n        let accountCreationFeeVault <- flowVaultRef.withdraw(amount: 0.001)\n        let token0Vault <- Token0Name.createEmptyVault()\n        let token1Vault <- Token1Name.createEmptyVault()\n        SwapFactory.createPair(token0Vault: <-token0Vault, token1Vault: <-token1Vault, accountCreationFee: <-accountCreationFeeVault)\n    }\n}",
      "AddLiquidity": "import FungibleToken from 0xf233dcee88fe0abe\nimport SwapFactory from 0xb063c16cac85dbd1\nimport SwapInterfaces from 0xb78ef7afa52ff906\nimport SwapConfig from 0xb78ef7afa52ff906\nimport SwapError from 0xb78ef7afa52ff906\ntransaction(\n    token0Key: String,\n    token1Key: String,\n    token0InDesired: UFix64,\n    token1InDesired: UFix64,\n    token0InMin: UFix64,\n    token1InMin: UFix64,\n    deadline: UFix64,\n    token0VaultPath: StoragePath,\n    token1VaultPath: StoragePath,\n) {\n    prepare(userAccount: AuthAccount) {\n        assert(deadline >= getCurrentBlock().timestamp, message:\n            SwapError.ErrorEncode(\n                msg: \"AddLiquidity: expired \".concat(deadline.toString()).concat(\" < \").concat(getCurrentBlock().timestamp.toString()),\n                err: SwapError.ErrorCode.EXPIRED\n            )\n        )\n        let pairAddr = SwapFactory.getPairAddress(token0Key: token0Key, token1Key: token1Key)\n            ?? panic(\"AddLiquidity: nonexistent pair \".concat(token0Key).concat(\" <-> \").concat(token1Key).concat(\", create pair first\"))\n        let pairPublicRef = getAccount(pairAddr).getCapability<&{SwapInterfaces.PairPublic}>(SwapConfig.PairPublicPath).borrow()!\n        let pairInfo = pairPublicRef.getPairInfo()\n        var token0In = 0.0\n        var token1In = 0.0\n        var token0Reserve = 0.0\n        var token1Reserve = 0.0\n        if token0Key == (pairInfo[0] as! String) {\n            token0Reserve = (pairInfo[2] as! UFix64)\n            token1Reserve = (pairInfo[3] as! UFix64)\n        } else {\n            token0Reserve = (pairInfo[3] as! UFix64)\n            token1Reserve = (pairInfo[2] as! UFix64)\n        }\n        if token0Reserve == 0.0 && token1Reserve == 0.0 {\n            token0In = token0InDesired\n            token1In = token1InDesired\n        } else {\n            var amount1Optimal = SwapConfig.quote(amountA: token0InDesired, reserveA: token0Reserve, reserveB: token1Reserve)\n            if (amount1Optimal <= token1InDesired) {\n                assert(amount1Optimal >= token1InMin, message:\n                    SwapError.ErrorEncode(\n                        msg: \"SLIPPAGE_OFFSET_TOO_LARGE expect min\".concat(token1InMin.toString()).concat(\" got \").concat(amount1Optimal.toString()),\n                        err: SwapError.ErrorCode.SLIPPAGE_OFFSET_TOO_LARGE\n                    )\n                )\n                token0In = token0InDesired\n                token1In = amount1Optimal\n            } else {\n                var amount0Optimal = SwapConfig.quote(amountA: token1InDesired, reserveA: token1Reserve, reserveB: token0Reserve)\n                assert(amount0Optimal <= token0InDesired)\n                assert(amount0Optimal >= token0InMin, message:\n                    SwapError.ErrorEncode(\n                        msg: \"SLIPPAGE_OFFSET_TOO_LARGE expect min\".concat(token0InMin.toString()).concat(\" got \").concat(amount0Optimal.toString()),\n                        err: SwapError.ErrorCode.SLIPPAGE_OFFSET_TOO_LARGE\n                    )\n                )\n                token0In = amount0Optimal\n                token1In = token1InDesired\n            }\n        }\n        let token0Vault <- userAccount.borrow<&FungibleToken.Vault>(from: token0VaultPath)!.withdraw(amount: token0In)\n        let token1Vault <- userAccount.borrow<&FungibleToken.Vault>(from: token1VaultPath)!.withdraw(amount: token1In)\n        let lpTokenVault <- pairPublicRef.addLiquidity(\n            tokenAVault: <- token0Vault,\n            tokenBVault: <- token1Vault\n        )\n        let lpTokenCollectionStoragePath = SwapConfig.LpTokenCollectionStoragePath\n        let lpTokenCollectionPublicPath = SwapConfig.LpTokenCollectionPublicPath\n        var lpTokenCollectionRef = userAccount.borrow<&SwapFactory.LpTokenCollection>(from: lpTokenCollectionStoragePath)\n        if lpTokenCollectionRef == nil {\n            destroy <- userAccount.load<@AnyResource>(from: lpTokenCollectionStoragePath)\n            userAccount.save(<-SwapFactory.createEmptyLpTokenCollection(), to: lpTokenCollectionStoragePath)\n            userAccount.link<&{SwapInterfaces.LpTokenCollectionPublic}>(lpTokenCollectionPublicPath, target: lpTokenCollectionStoragePath)\n            lpTokenCollectionRef = userAccount.borrow<&SwapFactory.LpTokenCollection>(from: lpTokenCollectionStoragePath)\n        }\n        lpTokenCollectionRef!.deposit(pairAddr: pairAddr, lpTokenVault: <- lpTokenVault)\n    }\n}",
      "RemoveLiquidity": "import FungibleToken from 0xf233dcee88fe0abe\nimport SwapFactory from 0xb063c16cac85dbd1\nimport SwapInterfaces from 0xb78ef7afa52ff906\nimport SwapConfig from 0xb78ef7afa52ff906\nimport SwapError from 0xb78ef7afa52ff906\ntransaction(\n    token0Key: String,\n    token1Key: String,\n    lpTokenAmount: UFix64,\n    token0OutMin: UFix64,\n    token1OutMin: UFix64,\n    deadline: UFix64,\n    token0VaultPath: StoragePath,\n    token1VaultPath: StoragePath,\n) {\n    prepare(userAccount: AuthAccount) {\n        assert(deadline >= getCurrentBlock().timestamp, message:\n            SwapError.ErrorEncode(\n                msg: \"RemoveLiquidity: expired \".concat(deadline.toString()).concat(\" < \").concat(getCurrentBlock().timestamp.toString()),\n                err: SwapError.ErrorCode.EXPIRED\n            )\n        )\n        let pairAddr = SwapFactory.getPairAddress(token0Key: token0Key, token1Key: token1Key)\n            ?? panic(\"RemoveLiquidity: nonexistent pair \".concat(token0Key).concat(\" <-> \").concat(token1Key).concat(\", create pair first\"))\n        let lpTokenCollectionRef = userAccount.borrow<&SwapFactory.LpTokenCollection>(from: SwapConfig.LpTokenCollectionStoragePath)\n            ?? panic(\"RemoveLiquidity: cannot borrow reference to LpTokenCollection\")\n        let lpTokenRemove <- lpTokenCollectionRef.withdraw(pairAddr: pairAddr, amount: lpTokenAmount)\n        let tokens <- getAccount(pairAddr).getCapability<&{SwapInterfaces.PairPublic}>(SwapConfig.PairPublicPath).borrow()!.removeLiquidity(lpTokenVault: <-lpTokenRemove)\n        let token0Vault <- tokens[0].withdraw(amount: tokens[0].balance)\n        let token1Vault <- tokens[1].withdraw(amount: tokens[1].balance)\n        destroy tokens\n        assert(token0Vault.balance >= token0OutMin && token1Vault.balance >= token1OutMin, message:\n            SwapError.ErrorEncode(\n                msg: \"RemoveLiquidity: INSUFFICIENT_REMOVE_LIQUIDITY_OUT_AMOUNT\",\n                err: SwapError.ErrorCode.SLIPPAGE_OFFSET_TOO_LARGE\n            )\n        )\n        let localVault0Ref = userAccount.borrow<&FungibleToken.Vault>(from: token0VaultPath)!\n        let localVault1Ref = userAccount.borrow<&FungibleToken.Vault>(from: token1VaultPath)!\n        if token0Vault.isInstance(localVault0Ref.getType()) {\n            localVault0Ref.deposit(from: <-token0Vault)\n            localVault1Ref.deposit(from: <-token1Vault)\n        } else {\n            localVault0Ref.deposit(from: <-token1Vault)\n            localVault1Ref.deposit(from: <-token0Vault)\n        }\n    }\n}",
      "SwapExactTokensForTokens": "import Token1Name from Token1Addr\nimport FungibleToken from 0xf233dcee88fe0abe\nimport SwapRouter from 0xa6850776a94e6551\nimport SwapError from 0xb78ef7afa52ff906\ntransaction(\n    tokenKeyFlatSplitPath: [String],\n    amountInSplit: [UFix64],\n    amountOutMin: UFix64,\n    deadline: UFix64,\n    tokenInVaultPath: StoragePath,\n    tokenOutVaultPath: StoragePath,\n    tokenOutReceiverPath: PublicPath,\n    tokenOutBalancePath: PublicPath,\n) {\n    prepare(userAccount: AuthAccount) {\n        assert(deadline >= getCurrentBlock().timestamp, message:\n            SwapError.ErrorEncode(\n                msg: \"EXPIRED\",\n                err: SwapError.ErrorCode.EXPIRED\n            )\n        )\n        let len = tokenKeyFlatSplitPath.length\n        let tokenInKey = tokenKeyFlatSplitPath[0]\n        let tokenOutKey = tokenKeyFlatSplitPath[len-1]\n        var tokenOutAmountTotal = 0.0\n        var tokenOutReceiverRef = userAccount.borrow<&FungibleToken.Vault>(from: tokenOutVaultPath)\n        if tokenOutReceiverRef == nil {\n            userAccount.save(<- Token1Name.createEmptyVault(), to: tokenOutVaultPath)\n            userAccount.link<&Token1Name.Vault{FungibleToken.Receiver}>(tokenOutReceiverPath, target: tokenOutVaultPath)\n            userAccount.link<&Token1Name.Vault{FungibleToken.Balance}>(tokenOutBalancePath, target: tokenOutVaultPath)\n            tokenOutReceiverRef = userAccount.borrow<&FungibleToken.Vault>(from: tokenOutVaultPath)\n        }\n        var pathIndex = 0\n        var i = 0\n        var path: [String] = []\n        while(i < len) {\n            var curTokenKey = tokenKeyFlatSplitPath[i]\n            path.append(curTokenKey)\n            if (curTokenKey == tokenOutKey) {\n                let tokenInAmount = amountInSplit[pathIndex]\n                let tokenInVault <- userAccount.borrow<&FungibleToken.Vault>(from: tokenInVaultPath)!.withdraw(amount: tokenInAmount)\n                let tokenOutVault <- SwapRouter.swapWithPath(vaultIn: <- tokenInVault, tokenKeyPath: path, exactAmounts: nil)\n                tokenOutAmountTotal = tokenOutAmountTotal + tokenOutVault.balance\n                tokenOutReceiverRef!.deposit(from: <- tokenOutVault)\n                path = []\n                pathIndex = pathIndex + 1\n            }\n            i = i + 1\n        }\n        assert(tokenOutAmountTotal >= amountOutMin, message:\n            SwapError.ErrorEncode(\n                msg: \"SLIPPAGE_OFFSET_TOO_LARGE expect min \".concat(amountOutMin.toString()).concat(\" got \").concat(tokenOutAmountTotal.toString()),\n                err: SwapError.ErrorCode.SLIPPAGE_OFFSET_TOO_LARGE\n            )\n        )\n    }\n}",
      "SwapTokensForExactTokens": "import Token1Name from Token1Addr\nimport FungibleToken from 0xf233dcee88fe0abe\nimport SwapRouter from 0xa6850776a94e6551\nimport SwapError from 0xb78ef7afa52ff906\ntransaction(\n    tokenKeyFlatSplitPath: [String],\n    amountOutSplit: [UFix64],\n    amountInMax: UFix64,\n    deadline: UFix64,\n    tokenInVaultPath: StoragePath,\n    tokenOutVaultPath: StoragePath,\n    tokenOutReceiverPath: PublicPath,\n    tokenOutBalancePath: PublicPath,\n) {\n    prepare(userAccount: AuthAccount) {\n        assert( deadline >= getCurrentBlock().timestamp, message:\n            SwapError.ErrorEncode(\n                msg: \"EXPIRED\",\n                err: SwapError.ErrorCode.EXPIRED\n            )\n        )\n        let len = tokenKeyFlatSplitPath.length\n        let tokenInKey = tokenKeyFlatSplitPath[0]\n        let tokenOutKey = tokenKeyFlatSplitPath[len-1]\n        var tokenOutAmountTotal = 0.0\n        var tokenOutReceiverRef = userAccount.borrow<&FungibleToken.Vault>(from: tokenOutVaultPath)\n        if tokenOutReceiverRef == nil {\n            userAccount.save(<- Token1Name.createEmptyVault(), to: tokenOutVaultPath)\n            userAccount.link<&Token1Name.Vault{FungibleToken.Receiver}>(tokenOutReceiverPath, target: tokenOutVaultPath)\n            userAccount.link<&Token1Name.Vault{FungibleToken.Balance}>(tokenOutBalancePath, target: tokenOutVaultPath)\n            tokenOutReceiverRef = userAccount.borrow<&FungibleToken.Vault>(from: tokenOutVaultPath)\n        }\n        var pathIndex = 0\n        var i = 0\n        var path: [String] = []\n        var amountInTotal = 0.0\n        while(i < len) {\n            var curTokenKey = tokenKeyFlatSplitPath[i]\n            path.append(curTokenKey)\n            if (curTokenKey == tokenOutKey) {\n                let tokenOutExpectAmount = amountOutSplit[pathIndex]\n                let amounts = SwapRouter.getAmountsIn(amountOut: tokenOutExpectAmount, tokenKeyPath: path)\n                let tokenInAmount = amounts[0]\n                amountInTotal = amountInTotal + tokenInAmount\n                let tokenInVault <- userAccount.borrow<&FungibleToken.Vault>(from: tokenInVaultPath)!.withdraw(amount: tokenInAmount)\n                let tokenOutVault <- SwapRouter.swapWithPath(vaultIn: <- tokenInVault, tokenKeyPath: path, exactAmounts: amounts)\n                tokenOutAmountTotal = tokenOutAmountTotal + tokenOutVault.balance\n                tokenOutReceiverRef!.deposit(from: <- tokenOutVault)\n                path = []\n                pathIndex = pathIndex + 1\n            }\n            i = i + 1\n        }\n        assert(amountInTotal <= amountInMax, message:\n            SwapError.ErrorEncode(\n                msg: \"SLIPPAGE_OFFSET_TOO_LARGE\",\n                err: SwapError.ErrorCode.SLIPPAGE_OFFSET_TOO_LARGE\n            )\n        )\n    }\n}",
      "MintAllTokens": "import FungibleToken from 0xf233dcee88fe0abe\nimport BUSD from 0xBUSD\nimport FUSD from 0x3c5959b568896393\nimport USDC from 0xUSDC\nimport USDT from 0xUSDT\nimport wFlow from 0xwFlow\nimport BLT from 0xBLT\nimport TestTokenA from 0xTestTokenA\nimport TestTokenB from 0xTestTokenB\nimport TestTokenC from 0xTestTokenC\ntransaction(mintAmount: UFix64) {\n    prepare(signer: AuthAccount) {\n        var vaultStoragePath = /storage/test_busdVault\n        var vaultReceiverPath = /public/test_busdReceiver\n        var vaultBalancePath = /public/test_busdBalance\n        var busdVaultRef = signer.borrow<&BUSD.Vault>(from: vaultStoragePath)\n        if busdVaultRef == nil {\n            destroy <- signer.load<@AnyResource>(from: vaultStoragePath)\n            signer.save(<-BUSD.createEmptyVault(), to: vaultStoragePath)\n            signer.link<&BUSD.Vault{FungibleToken.Receiver}>(vaultReceiverPath, target: vaultStoragePath)\n            signer.link<&BUSD.Vault{FungibleToken.Balance}>(vaultBalancePath, target: vaultStoragePath)\n        }\n        busdVaultRef = signer.borrow<&BUSD.Vault>(from: vaultStoragePath)\n        busdVaultRef!.deposit(from: <-BUSD.test_minter.mintTokens(amount: mintAmount))\n        vaultStoragePath = /storage/test_fusdVault\n        vaultReceiverPath = /public/test_fusdReceiver\n        vaultBalancePath = /public/test_fusdBalance\n        var fusdVaultRef = signer.borrow<&FUSD.Vault>(from: vaultStoragePath)\n        if fusdVaultRef == nil {\n            destroy <- signer.load<@AnyResource>(from: vaultStoragePath)\n            signer.save(<-FUSD.createEmptyVault(), to: vaultStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Receiver}>(vaultReceiverPath, target: vaultStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Balance}>(vaultBalancePath, target: vaultStoragePath)\n        }\n        fusdVaultRef = signer.borrow<&FUSD.Vault>(from: vaultStoragePath)\n        fusdVaultRef!.deposit(from: <-FUSD.test_minter.mintTokens(amount: mintAmount))\n        vaultStoragePath = /storage/test_usdcVault\n        vaultReceiverPath = /public/test_usdcReceiver\n        vaultBalancePath = /public/test_usdcBalance\n        var usdcVaultRef = signer.borrow<&USDC.Vault>(from: vaultStoragePath)\n        if usdcVaultRef == nil {\n            destroy <- signer.load<@AnyResource>(from: vaultStoragePath)\n            signer.save(<-USDC.createEmptyVault(), to: vaultStoragePath)\n            signer.link<&USDC.Vault{FungibleToken.Receiver}>(vaultReceiverPath, target: vaultStoragePath)\n            signer.link<&USDC.Vault{FungibleToken.Balance}>(vaultBalancePath, target: vaultStoragePath)\n        }\n        usdcVaultRef = signer.borrow<&USDC.Vault>(from: vaultStoragePath)\n        usdcVaultRef!.deposit(from: <-USDC.test_minter.mintTokens(amount: mintAmount))\n        vaultStoragePath = /storage/test_usdtVault\n        vaultReceiverPath = /public/test_usdtReceiver\n        vaultBalancePath = /public/test_usdtBalance\n        var usdtVaultRef = signer.borrow<&USDT.Vault>(from: vaultStoragePath)\n        if usdtVaultRef == nil {\n            destroy <- signer.load<@AnyResource>(from: vaultStoragePath)\n            signer.save(<-USDT.createEmptyVault(), to: vaultStoragePath)\n            signer.link<&USDT.Vault{FungibleToken.Receiver}>(vaultReceiverPath, target: vaultStoragePath)\n            signer.link<&USDT.Vault{FungibleToken.Balance}>(vaultBalancePath, target: vaultStoragePath)\n        }\n        usdtVaultRef = signer.borrow<&USDT.Vault>(from: vaultStoragePath)\n        usdtVaultRef!.deposit(from: <-USDT.test_minter.mintTokens(amount: mintAmount))\n        vaultStoragePath = /storage/test_wflowVault\n        vaultReceiverPath = /public/test_wflowReceiver\n        vaultBalancePath = /public/test_wflowBalance\n        var wflowVaultRef = signer.borrow<&wFlow.Vault>(from: vaultStoragePath)\n        if wflowVaultRef == nil {\n            destroy <- signer.load<@AnyResource>(from: vaultStoragePath)\n            signer.save(<-wFlow.createEmptyVault(), to: vaultStoragePath)\n            signer.link<&wFlow.Vault{FungibleToken.Receiver}>(vaultReceiverPath, target: vaultStoragePath)\n            signer.link<&wFlow.Vault{FungibleToken.Balance}>(vaultBalancePath, target: vaultStoragePath)\n        }\n        wflowVaultRef = signer.borrow<&wFlow.Vault>(from: vaultStoragePath)\n        wflowVaultRef!.deposit(from: <-wFlow.test_minter.mintTokens(amount: mintAmount))\n        vaultStoragePath = /storage/test_bltVault\n        vaultReceiverPath = /public/test_bltReceiver\n        vaultBalancePath = /public/test_bltBalance\n        var bLTVaultRef = signer.borrow<&BLT.Vault>(from: vaultStoragePath)\n        if bLTVaultRef == nil {\n            destroy <- signer.load<@AnyResource>(from: vaultStoragePath)\n            signer.save(<-BLT.createEmptyVault(), to: vaultStoragePath)\n            signer.link<&BLT.Vault{FungibleToken.Receiver}>(vaultReceiverPath, target: vaultStoragePath)\n            signer.link<&BLT.Vault{FungibleToken.Balance}>(vaultBalancePath, target: vaultStoragePath)\n        }\n        bLTVaultRef = signer.borrow<&BLT.Vault>(from: vaultStoragePath)\n        bLTVaultRef!.deposit(from: <-BLT.test_minter.mintTokens(amount: mintAmount))\n        vaultStoragePath = /storage/testTokenAVault\n        vaultReceiverPath = /public/testTokenAReceiver\n        vaultBalancePath = /public/testTokenABalance\n        var testTokenAVaultRef = signer.borrow<&TestTokenA.Vault>(from: vaultStoragePath)\n        if testTokenAVaultRef == nil {\n            destroy <- signer.load<@AnyResource>(from: vaultStoragePath)\n            signer.save(<-TestTokenA.createEmptyVault(), to: vaultStoragePath)\n            signer.link<&TestTokenA.Vault{FungibleToken.Receiver}>(vaultReceiverPath, target: vaultStoragePath)\n            signer.link<&TestTokenA.Vault{FungibleToken.Balance}>(vaultBalancePath, target: vaultStoragePath)\n        }\n        testTokenAVaultRef = signer.borrow<&TestTokenA.Vault>(from: vaultStoragePath)\n        testTokenAVaultRef!.deposit(from: <-TestTokenA.test_minter.mintTokens(amount: mintAmount))\n        vaultStoragePath = /storage/testTokenBVault\n        vaultReceiverPath = /public/testTokenBReceiver\n        vaultBalancePath = /public/testTokenBBalance\n        var testTokenBVaultRef = signer.borrow<&TestTokenB.Vault>(from: vaultStoragePath)\n        if testTokenBVaultRef == nil {\n            destroy <- signer.load<@AnyResource>(from: vaultStoragePath)\n            signer.save(<-TestTokenB.createEmptyVault(), to: vaultStoragePath)\n            signer.link<&TestTokenB.Vault{FungibleToken.Receiver}>(vaultReceiverPath, target: vaultStoragePath)\n            signer.link<&TestTokenB.Vault{FungibleToken.Balance}>(vaultBalancePath, target: vaultStoragePath)\n        }\n        testTokenBVaultRef = signer.borrow<&TestTokenB.Vault>(from: vaultStoragePath)\n        testTokenBVaultRef!.deposit(from: <-TestTokenB.test_minter.mintTokens(amount: mintAmount))\n        vaultStoragePath = /storage/testTokenCVault\n        vaultReceiverPath = /public/testTokenCReceiver\n        vaultBalancePath = /public/testTokenCBalance\n        var testTokenCVaultRef = signer.borrow<&TestTokenC.Vault>(from: vaultStoragePath)\n        if testTokenCVaultRef == nil {\n            destroy <- signer.load<@AnyResource>(from: vaultStoragePath)\n            signer.save(<-TestTokenC.createEmptyVault(), to: vaultStoragePath)\n            signer.link<&TestTokenC.Vault{FungibleToken.Receiver}>(vaultReceiverPath, target: vaultStoragePath)\n            signer.link<&TestTokenC.Vault{FungibleToken.Balance}>(vaultBalancePath, target: vaultStoragePath)\n        }\n        testTokenCVaultRef = signer.borrow<&TestTokenC.Vault>(from: vaultStoragePath)\n        testTokenCVaultRef!.deposit(from: <-TestTokenC.test_minter.mintTokens(amount: mintAmount))\n    }\n}\n"
    },
    "Scripts": {
      "QueryTokenNames": "pub fun main(queryAddr: Address): [String] {\n    let names = getAccount(queryAddr).contracts.names\n    let tokenNames: [String] = []\n    let colon: UInt8 = 58\n    let space: UInt8 = 32\n    let brace: UInt8 = 123\n    let tokenIndentifier: [UInt8] = [70, 117, 110, 103, 105, 98, 108, 101, 84, 111, 107, 101, 110] \n    let indentifierLength = tokenIndentifier.length\n    for name in names {\n        let code = getAccount(queryAddr).contracts.get(name: name)!.code\n        let codeLength = code.length\n        var isToken = false\n        var i = 13\n        while(i < codeLength-1) {\n            if code[i] == brace {\n                break\n            }\n            if code[i] == colon && code[i+1] == space {\n                i = i + 1\n                while(code[i] == space && i < codeLength) {\n                    i = i + 1\n                }\n                var j = 0\n                while(j < indentifierLength && i < codeLength) {\n                    if code[i] == tokenIndentifier[j] {\n                        i = i + 1\n                        j = j + 1\n                    } else {\n                        break\n                    }\n                }\n                if j == indentifierLength && (code[i]==space || code[i]==brace) {\n                    isToken = true\n                    break\n                }\n            } else {\n                i = i + 1\n            }\n        }\n        if isToken {\n            tokenNames.append(name)\n        }\n    }\n    return tokenNames\n}",
      "QueryPairArrayAddr": "import SwapFactory from 0xb063c16cac85dbd1\npub fun main(from: UInt64, to: UInt64): [Address] {\n    return SwapFactory.getSlicedPairs(from: from, to: to)\n}\n",
      "QueryPairArrayInfo": "import SwapFactory from 0xb063c16cac85dbd1\npub fun main(from: UInt64, to: UInt64): [AnyStruct] {\n    return SwapFactory.getSlicedPairInfos(from: from, to: to)\n}\n",
      "QueryPairInfoByAddrs": "import SwapInterfaces from 0xb78ef7afa52ff906\nimport SwapConfig from 0xb78ef7afa52ff906\npub fun main(pairAddrs: [Address]): [AnyStruct] {\n    var res: [AnyStruct] = []\n    var i = 0\n    var len = pairAddrs.length\n    while(i < len) {\n        res.append(\n            getAccount(pairAddrs[i]).getCapability<&{SwapInterfaces.PairPublic}>(SwapConfig.PairPublicPath).borrow()!.getPairInfo()\n        )\n        i = i + 1\n    }\n    return res\n}\n",
      "QueryPairInfoByTokenKey": "import SwapFactory from 0xb063c16cac85dbd1\npub fun main(token0Key:String ,token1Key:String): AnyStruct? {\n    return SwapFactory.getPairInfo(token0Key: token0Key, token1Key: token1Key)\n}",
      "QueryUserAllLiquidities": "import SwapFactory from 0xb063c16cac85dbd1\nimport SwapConfig from 0xb78ef7afa52ff906\nimport SwapInterfaces from 0xb78ef7afa52ff906\npub fun main(userAddr: Address): {Address: UFix64} {\n    var lpTokenCollectionPublicPath = SwapConfig.LpTokenCollectionPublicPath\n    let lpTokenCollectionCap = getAccount(userAddr).getCapability<&{SwapInterfaces.LpTokenCollectionPublic}>(lpTokenCollectionPublicPath)\n    if lpTokenCollectionCap.check() == false {\n        return {}\n    }\n    let lpTokenCollectionRef = lpTokenCollectionCap.borrow()!\n    let liquidityPairAddrs = lpTokenCollectionRef.getAllLPTokens()\n    var res: {Address: UFix64} = {}\n    for pairAddr in liquidityPairAddrs {\n        var lpTokenAmount = lpTokenCollectionRef.getLpTokenBalance(pairAddr: pairAddr)\n        res[pairAddr] = lpTokenAmount\n    }\n    return res\n}",
      "QueryTimestamp": "pub fun main(): UFix64 {\n    return getCurrentBlock().timestamp\n}",
      "QueryVaultBalanceBatched": "import FungibleToken from 0xf233dcee88fe0abe\npub fun main(userAddr: Address, vaultPaths: [PublicPath]): [UFix64] {\n    var balances: [UFix64] = []\n    for vaultPath in vaultPaths {\n        let vaultBalance = getAccount(userAddr).getCapability<&{FungibleToken.Balance}>(vaultPath)\n        if vaultBalance.check() == false || vaultBalance.borrow() == nil {\n            balances.append(0.0)\n        } else {\n            balances.append(vaultBalance.borrow()!.balance)\n        }\n    }\n    return balances\n}",
      "QueryTokenPathPrefix": "import FungibleToken from 0xf233dcee88fe0abe\npub fun main(tokenName: String, tokenAddr: Address, userAddr: Address): {String: AnyStruct} {\n    let code = getAccount(tokenAddr).contracts.get(name: tokenName)!.code\n    var localPrefix = \"\"\n    var balancePath = /public/PathPrefix1Balance\n    var receiverPath = /public/PathPrefix1Receiver\n    if getAccount(userAddr).getCapability<&{FungibleToken.Balance}>(balancePath).check() && getAccount(userAddr).getCapability<&{FungibleToken.Receiver}>(receiverPath).check() {\n        localPrefix = \"PathPrefix1\"\n    }\n    balancePath = /public/PathPrefix2Balance\n    receiverPath = /public/PathPrefix2Receiver\n    if getAccount(userAddr).getCapability<&{FungibleToken.Balance}>(balancePath).check() && getAccount(userAddr).getCapability<&{FungibleToken.Receiver}>(receiverPath).check() {\n        localPrefix = \"PathPrefix2\"\n    }\n    balancePath = /public/PathPrefix3Balance\n    receiverPath = /public/PathPrefix3Receiver\n    if getAccount(userAddr).getCapability<&{FungibleToken.Balance}>(balancePath).check() && getAccount(userAddr).getCapability<&{FungibleToken.Receiver}>(receiverPath).check() {\n        localPrefix = \"PathPrefix3\"\n    }\n    balancePath = /public/PathPrefix4Balance\n    receiverPath = /public/PathPrefix4Receiver\n    if getAccount(userAddr).getCapability<&{FungibleToken.Balance}>(balancePath).check() && getAccount(userAddr).getCapability<&{FungibleToken.Receiver}>(receiverPath).check() {\n        localPrefix = \"PathPrefix4\"\n    }\n    return {\n        \"LocalPrefix\": localPrefix,\n        \"TokenCode\": code\n    }\n}"
    }
  },
  "Router": {
    "CenterTokens": [
      "A.1654653399040a61.FlowToken",
      "A.3c5959b568896393.FUSD",
      "A.b19436aae4d94622.FiatToken",
      "A.cfdd90d4a00f7b5b.TeleportedTetherToken",
      "A.231cc0dbbcffc4b7.ceWETH",
      "A.231cc0dbbcffc4b7.ceWBTC"
    ]
  }
}